package microsvc

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"

	"github.com/kevinyjn/gocom/config/results"
	"github.com/kevinyjn/gocom/logger"
	"github.com/kevinyjn/gocom/microsvc/autodocs"
	"github.com/kevinyjn/gocom/microsvc/delegates"
	"github.com/kevinyjn/gocom/microsvc/events"
	"github.com/kevinyjn/gocom/microsvc/filters"
	"github.com/kevinyjn/gocom/microsvc/observers"
	"github.com/kevinyjn/gocom/microsvc/serializers"
	"github.com/kevinyjn/gocom/microsvc/visitors"
	"github.com/kevinyjn/gocom/mq"
	"github.com/kevinyjn/gocom/mq/mqenv"
	"github.com/kevinyjn/gocom/utils"
)

// MQHandler interface of mq handler
type MQHandler interface {
	autodocs.Handler
	GetGroup() string
	GetName() string
	PreExecute(mqenv.MQConsumerMessage) *mqenv.MQPublishMessage
	Execute(mqenv.MQConsumerMessage) *mqenv.MQPublishMessage
	SetMQTopic(string)
	GetMQTopic() string
}

// MQHandlers interface of mq handler manager
type MQHandlers interface {
	Execute(mqenv.MQConsumerMessage) *mqenv.MQPublishMessage
	RegisterHandlers(topicCategory string, hs map[string]MQHandler) error
	GetHandler(routingKey string) autodocs.Handler
	AllDocHandlers() []autodocs.Handler
}

// global variables
var (
	_mqHandlers = mqHandlers{
		handlers:         map[string]MQHandler{},
		m:                sync.RWMutex{},
		registeredTopics: map[string]bool{},
	}
)

type mqHandlerCallback func(mqenv.MQConsumerMessage, interface{}) interface{}

// mqHandler consumer of mq that generated by controller object
type mqHandler struct {
	Name       string
	Group      string
	MQTopic    string
	RoutingKey string
	caller     reflect.Value
	inTypes    []paramTypeWrapper
	outTypes   []paramTypeWrapper
	controller MQController
}

// mqHandlers of consumers
type mqHandlers struct {
	handlers         map[string]MQHandler
	m                sync.RWMutex
	registeredTopics map[string]bool
}

type paramTypeWrapper struct {
	valueType       reflect.Type
	isPtr           bool
	isMQParameter   bool
	isSerializable  bool
	hasStatusCode   bool
	isErrorStatus   bool
	isError         bool
	serializingType string
}

// GetHandlers of loaded mq handlers
func GetHandlers() MQHandlers {
	return &_mqHandlers
}

// GetGroup of mq handler
func (h *mqHandler) GetGroup() string {
	return h.Group
}

// GetName of mq handler
func (h *mqHandler) GetName() string {
	return h.Name
}

// GetRoutingKey routing key for dispatcher
func (h *mqHandler) GetRoutingKey() string {
	return h.RoutingKey
}

// GetSummary summary of api
func (h *mqHandler) GetSummary() string {
	return fmt.Sprintf("接口 %s.%s", h.Group, h.Name)
}

// GetDescription description of api
func (h *mqHandler) GetDescription() string {
	return fmt.Sprintf("接口名称： %s\n\n接口描述： 本文档描述该接口的出入参数，该HTTP请求模式仅为方便单用例测试用，实际接入工作应以消息队列接入形式。\n\n消息队列： %s\n\n消息路由键： %s\n", h.Name, h.MQTopic, h.RoutingKey)
}

// GetOperationID operation id of api
func (h *mqHandler) GetOperationID() string {
	return h.Name
}

func (h *mqHandler) PreExecute(msg mqenv.MQConsumerMessage) *mqenv.MQPublishMessage {
	var resp *mqenv.MQPublishMessage
	switch msg.RoutingKey {
	// case h.Group + ".ping":
	// 	resObj := results.NewResultObjectWithRequestSn(msg.MessageID)
	// 	resObj.Code = results.OK
	// 	resObj.Message = "pong"
	// 	resp = mqenv.NewMQResponseMessage([]byte(resObj.Encode()), &msg)
	// 	break
	}
	return resp
}

// Execute do execute handler with callable and formatted arguments
func (h *mqHandler) Execute(msg mqenv.MQConsumerMessage) *mqenv.MQPublishMessage {
	inParams, err := h.formatInputs(msg)
	if nil != err {
		return h.postOnError(msg, results.InnerError, err)
	}

	numIn := len(inParams)
	evs := make([]events.Event, numIn)
	idx := 0
	for i, v := range inParams {
		if false == h.inTypes[i].isMQParameter {
			ev := events.CreateEventFromConsumerMessageAndPayload(h.GetGroup(), h.GetName(), msg, v.Interface())
			evs[idx] = ev
			idx++
		}
	}
	if idx < numIn {
		evs = evs[:idx]
	}

	// pre execute
	for _, ev := range evs {
		ok, err := h.controller.Filter(ev)
		if false == ok {
			return h.postOnError(msg, results.Forbidden, err)
		}

		visits := h.controller.GetVisitors(h.Name)
		if nil != visits {
			for _, visitor := range visits {
				visitor.Visit(ev)
			}
		}
	}

	// do execute
	var resp *mqenv.MQPublishMessage
	delegts := h.controller.GetDelegates(h.Name)
	if len(delegts) > 0 {
		var ev events.Event
		if len(evs) > 0 {
			ev = evs[0]
		} else {
			ev = events.CreateEventFromConsumerMessage(h.Group, h.Name, msg)
		}
		for i, delegate := range delegts {
			if i > 0 {
				// we strongly recommend to register one delegate per handler, for that the response to querier were once
				go delegate.Execute(ev)
			}
			resEv := delegate.Execute(ev)
			if nil != resEv {
				ev.SetStatus(resEv.GetStatus())
				ev.SetDescription(resEv.GetDescription())
				respMsg := events.CreatePublishMessageFromEventAndPayload(resEv, resEv.GetOriginBody())
				resp = &respMsg
			}
		}
	} else {
		outParams := h.caller.Call(inParams)
		resp, err = h.parseCallOutputs(msg, outParams)
	}

	if nil == err {
		// post execute
		for _, ev := range evs {
			observs := h.controller.GetObservers(h.Name)
			if nil != observs {
				for _, observer := range observs {
					observer.Observe(ev)
				}
			}
		}
	}

	return resp
}

func (h *mqHandler) formatInputs(msg mqenv.MQConsumerMessage) ([]reflect.Value, error) {
	numIn := len(h.inTypes)
	inParams := make([]reflect.Value, numIn)
	var err error
	for i := 0; i < numIn; i++ {
		iw := h.inTypes[i]
		if iw.isMQParameter {
			if iw.isPtr {
				inParams[i] = reflect.ValueOf(&msg)
			} else {
				inParams[i] = reflect.ValueOf(msg)
			}
		} else {
			var v reflect.Value
			v, err = iw.parsePayload(msg.Body)
			inParams[i] = v
		}
	}
	return inParams, err
}

func (h *mqHandler) parseCallOutputs(msg mqenv.MQConsumerMessage, outParams []reflect.Value) (*mqenv.MQPublishMessage, HandlerError) {
	numOut := len(h.outTypes)
	var pubMsg *mqenv.MQPublishMessage
	resObj := results.NewResultObjectWithRequestSn(msg.MessageID)
	resObj.Code = results.SUCCESS
	resObj.Message = "Success"
	var err error
	var errStatus HandlerError
	var serializer serializers.Serializable
	var serializeObj interface{}
	var payload []byte
	for i := 0; i < numOut; i++ {
		ow := h.outTypes[i]
		ot := ow.valueType
		outParam := outParams[i].Interface()
		if ow.isPtr {
			ot = ot.Elem()
		}
		if ow.isMQParameter {
			if ow.isPtr {
				pubMsg, _ = outParam.(*mqenv.MQPublishMessage)
			} else {
				pubMsg2, ok := outParam.(mqenv.MQPublishMessage)
				if ok {
					pubMsg = &pubMsg2
				}
			}
			if nil != pubMsg {
				continue
			} else {
				logger.Error.Printf("process %s the response %+v were not %s type", h.RoutingKey, outParam, ot.Name())
				err = fmt.Errorf("Consider the response as %s failed", ot.Name())
			}
		} else if ow.isErrorStatus {
			if nil != outParam {
				errStatus, _ = outParam.(HandlerError)
				if nil == errStatus {
					er, _ := outParam.(error)
					if nil != er {
						errStatus = NewHandlerError(results.InnerError, er.Error())
					}
				}
			}
		} else if ow.isError {
			if nil != outParam {
				er, _ := outParam.(error)
				if nil != er {
					errStatus = NewHandlerError(results.InnerError, er.Error())
				}
			}
		} else {
			if ow.isSerializable && ow.hasStatusCode {
				var serializable serializers.SerializableParam
				var ok bool
				if ow.isPtr {
					ot = ot.Elem()
					serializable, ok = outParam.(serializers.SerializableParam)
				} else {
					iv := reflect.New(ow.valueType)
					utils.DeeplyCopyObject(outParam, iv.Interface())
					serializable, ok = iv.Interface().(serializers.SerializableParam)
				}
				if ok && nil != serializable {
					payload, err = serializable.Serialize()
				} else {
					logger.Error.Printf("process %s while the response type:%s were not serializable", h.RoutingKey, ot.Name())
					err = fmt.Errorf("%s were not serializable", ot.Name())
				}
			} else {
				serializer = serializers.GetSerializer(ow.serializingType)
				if nil != serializer {
					if ow.hasStatusCode {
						if ow.isPtr {
							serializeObj = outParam
						} else {
							serializeObj = &outParam
						}
					} else {
						resObj.Data = outParam
						// not fill serializeObj here for get the expected status code maybe in second response parameter
					}
				} else {
					logger.Error.Printf("process %s while get serializer for response %s by serializing type:%s not found", h.RoutingKey, ot.Name(), ow.serializingType)
					err = fmt.Errorf("Get serializer for response %s by serializing type:%s not found", ot.Name(), ow.serializingType)
				}
			}
		}
	}

	if nil != pubMsg {
		return pubMsg, nil
	}
	if nil != serializer {
		if nil == serializeObj {
			// the result object data field ed first response parameter before
			serializeObj = &resObj
			if nil != errStatus {
				resObj.Code = errStatus.StatusCode()
				resObj.Message = errStatus.Error()
			} else if nil != err {
				logger.Error.Printf("format response object for handler %s response while get error:%+v without status code, treat as inner server error", h.RoutingKey, err)
				resObj.Code = results.InnerError
				resObj.Message = err.Error()
			} else {
				resObj.Code = results.OK
				resObj.Message = "Success"
			}
		}
		payload, err = serializer.Serialize(serializeObj)
		if nil != err {
			logger.Error.Printf("handler %s serializing response:%+v as %s type failed with error:%+v", h.RoutingKey, serializeObj, serializer.ContentType(), err)
		}
	}

	pubMsg = &mqenv.MQPublishMessage{
		Exchange:      msg.Exchange,
		RoutingKey:    msg.RoutingKey,
		ReplyTo:       msg.ReplyTo,
		CorrelationID: msg.CorrelationID,
		MessageID:     msg.MessageID,
		AppID:         msg.AppID,
		UserID:        msg.UserID,
		ContentType:   msg.ContentType,
		Body:          payload,
	}
	if nil == payload {
		if nil != errStatus {
			resObj.Code = errStatus.StatusCode()
			resObj.Message = errStatus.Error()
		} else if nil != err {
			errStatus = NewHandlerError(results.InnerError, err.Error())
			resObj.Code = results.InnerError
			resObj.Message = err.Error()
		}
		logger.Error.Printf("handler %s formates response while got empty payload, responses code:%d and error message:%s", h.RoutingKey, resObj.Code, resObj.Message)
		pubMsg.Body = []byte(resObj.Encode())
	}
	return pubMsg, errStatus
}

func (h *mqHandler) postOnError(msg mqenv.MQConsumerMessage, status int, err error) *mqenv.MQPublishMessage {
	if nil != err {
		if "" != msg.ReplyTo && "" != msg.CorrelationID {
			result := results.NewResultObjectWithRequestSn(msg.MessageID)
			result.Code = status
			result.Message = err.Error()
			resp := &mqenv.MQPublishMessage{
				Body:          []byte(result.Encode()),
				Exchange:      msg.Exchange,
				RoutingKey:    msg.RoutingKey,
				CorrelationID: msg.CorrelationID,
				ReplyTo:       msg.ReplyTo,
				MessageID:     msg.MessageID,
				AppID:         msg.AppID,
				UserID:        msg.UserID,
				ContentType:   "application/json",
			}
			return resp
		}
	}
	return nil
}

// GetParametersDocsInfo for auto docs
func (h *mqHandler) GetParametersDocsInfo() []autodocs.ParameterInfo {
	var schema *autodocs.DefinitionInfo
	for _, it := range h.inTypes {
		if it.isMQParameter {
			continue
		} else if it.isErrorStatus || it.isError {
			continue
		}
		schema = &autodocs.DefinitionInfo{
			Type:       "object",
			Properties: autodocs.ParseResponseParameters(it.valueType, it.GetParameterFieldSerializingTagName()),
		}
		break
	}
	parameters := []autodocs.ParameterInfo{
		{
			Type:        "object",
			Name:        "body",
			In:          "body",
			Description: "入参包体",
			Required:    true,
			Schema:      schema,
		},
	}
	return parameters
}

// GetRequestBodyDocsInfo for auto docs
func (h *mqHandler) GetRequestBodyDocsInfo() autodocs.RequestBodyInfo {
	schemaInfo := autodocs.SchemaInfo{
		Description: "入参",
	}
	for _, it := range h.inTypes {
		if it.isMQParameter {
			continue
		} else if it.isErrorStatus || it.isError {
			continue
		}
		schemaInfo.SerializationType = "application/" + it.GetParameterFieldSerializingTagName()
		schemaInfo.Schema = &autodocs.DefinitionInfo{
			Type:       "object",
			Properties: autodocs.ParseResponseParameters(it.valueType, it.GetParameterFieldSerializingTagName()),
		}
		break
	}
	requestDescription := "本文档描述该接口的出入参数，该HTTP请求模式仅为方便单用例测试用，实际接入工作应以消息队列接入形式。"
	requestInfo := autodocs.RequestBodyInfo{
		Required:    true,
		Description: requestDescription,
		Content: map[string]autodocs.SchemaInfo{
			schemaInfo.SerializationType: schemaInfo,
		},
	}

	return requestInfo
}

// GetResponsesDocsInfo for auto docs
func (h *mqHandler) GetResponsesDocsInfo() map[string]autodocs.SchemaInfo {
	responses := map[string]autodocs.SchemaInfo{}
	okResponse := autodocs.SchemaInfo{
		Description: "成功响应",
	}
	rootResponseSchema := autodocs.DefinitionInfo{
		Type: "object",
		Properties: map[string]autodocs.PropertyInfo{
			"code": {
				Type:        "integer",
				Description: "响应编码（0：成功，非0：失败）",
			},
			"message": {
				Type:        "string",
				Description: "响应结果描述信息",
				Example:     "响应结果描述",
			},
		},
	}
	for _, ot := range h.outTypes {
		if ot.isMQParameter {
			continue
		} else if ot.isErrorStatus || ot.isError {
			continue
		}
		respSchema := autodocs.DefinitionInfo(rootResponseSchema)
		respSchema.Properties["data"] = autodocs.PropertyInfo{
			Type:        "object",
			Description: "响应数据",
			Properties:  autodocs.ParseResponseParameters(ot.valueType, ot.GetParameterFieldSerializingTagName()),
		}
		okResponse.Schema = &respSchema
	}
	responses["0"] = okResponse
	responses["非0"] = autodocs.SchemaInfo{
		Description: "失败响应",
		Schema: &autodocs.DefinitionInfo{
			Properties: map[string]autodocs.PropertyInfo{
				"code": {
					Type:        "integer",
					Description: "失败编码",
					Example:     strconv.Itoa(results.InvalidInput),
				},
				"message": {
					Type:        "string",
					Description: "失败原因",
					Example:     "请填写合法参数",
				},
			},
		},
	}
	return responses
}

// SetMQTopic for auto docs
func (h *mqHandler) SetMQTopic(topic string) {
	h.MQTopic = topic
}

// GetMQTopic for auto docs
func (h *mqHandler) GetMQTopic() string {
	return h.MQTopic
}

// Execute do execute handler registered by mq consumer message
func (hm *mqHandlers) Execute(msg mqenv.MQConsumerMessage) *mqenv.MQPublishMessage {
	hm.m.RLock()
	h, ok := hm.handlers[msg.RoutingKey]
	hm.m.RUnlock()
	if false == ok || nil == h {
		logger.Error.Printf("handle Execute of consumer message routingKey:%s messageId:%s that the handle object on this message were nil", msg.RoutingKey, msg.MessageID)
		return hm.postOnError(msg, results.NotFound, fmt.Errorf("Handler by routingKey:%s not found", msg.RoutingKey))
	}

	if logger.IsDebugEnabled() {
		logger.Debug.Printf("handling processor by routingKey:%s", msg.RoutingKey)
	}
	// pre execute
	resp := h.PreExecute(msg)
	if nil != resp {
		return resp
	}

	// do execute
	resp = h.Execute(msg)

	// post execute

	return resp
}

// RegisterHandlers on topic
func (hm *mqHandlers) RegisterHandlers(topicCategory string, hs map[string]MQHandler) error {
	topicConfig := mq.GetMQConfig(topicCategory)
	if nil == topicConfig {
		logger.Error.Printf("register mq handlers with topic category:%s while the topic config on this category does not exists", topicCategory)
		return fmt.Errorf("topic category:%s does not exists", topicCategory)
	}
	topic := topicConfig.Topic
	if "" == topic {
		if "" != topicConfig.Exchange.Name {
			topic = topicConfig.Exchange.Name
		} else {
			topic = topicConfig.Queue
		}
	}
	hm.m.Lock()
	for rk, h := range hs {
		h.SetMQTopic(topic)
		hm.handlers[rk] = h
	}
	hm.m.Unlock()
	if false == hm.registeredTopics[topicConfig.Topic] {
		consumeProxy := mqenv.MQConsumerProxy{
			Queue:       topicConfig.Topic,
			ConsumerTag: topicConfig.Topic,
			Callback:    hm.Execute,
			AutoAck:     true,
		}
		err := mq.ConsumeMQ(topicCategory, &consumeProxy)
		return err
	}
	return nil
}

func (hm *mqHandlers) postOnError(msg mqenv.MQConsumerMessage, status int, err error) *mqenv.MQPublishMessage {
	if nil != err {
		if "" != msg.ReplyTo && "" != msg.CorrelationID {
			result := results.NewResultObjectWithRequestSn(msg.MessageID)
			result.Code = status
			result.Message = err.Error()
			resp := &mqenv.MQPublishMessage{
				Body:          []byte(result.Encode()),
				Exchange:      msg.Exchange,
				RoutingKey:    msg.RoutingKey,
				CorrelationID: msg.CorrelationID,
				ReplyTo:       msg.ReplyTo,
				MessageID:     msg.MessageID,
				AppID:         msg.AppID,
				UserID:        msg.UserID,
				ContentType:   "application/json",
			}
			return resp
		}
	}
	return nil
}

func (hm *mqHandlers) GetHandler(routingKey string) autodocs.Handler {
	hm.m.RLock()
	var h autodocs.Handler
	if nil != hm.handlers {
		h, _ = hm.handlers[routingKey]
	}
	hm.m.RUnlock()
	return h
}

// AllDocHandlers all handlers for documentation
func (hm *mqHandlers) AllDocHandlers() []autodocs.Handler {
	hm.m.RLock()
	l := len(hm.handlers)
	handlers := make([]autodocs.Handler, l)
	if nil != hm.handlers {
		i := 0
		for _, h := range hm.handlers {
			if nil != h {
				handlers[i] = h
				i++
			}
		}
		if i < l {
			handlers = handlers[:i]
		}
	}
	hm.m.RUnlock()
	return handlers
}

// analyzeControllerHandlers parse the controller mq handlers
func analyzeControllerHandlers(controller MQController) map[string]MQHandler {
	result := map[string]MQHandler{}
	rv := reflect.ValueOf(controller)
	rtv := reflect.TypeOf(controller)
	controllerValue := rv

	ml := rv.NumMethod()
	var controllerName string
	if rv.Type().Kind() == reflect.Ptr {
		controllerName = rtv.Elem().Name()
		controllerValue = rv.Elem()
	} else {
		controllerName = rtv.Name()
	}
	cmt := reflect.TypeOf(mqenv.MQConsumerMessage{})
	pmt := reflect.TypeOf(mqenv.MQPublishMessage{})
	paramSerializingType := getControllerSerializationType(controllerValue)
	handleGroup := utils.KebabCaseString(strings.Replace(controllerName, "Controller", "", 1))
	if "" == controller.GetName() {
		controller.SetName(handleGroup)
	}
	SetController(controller.GetName(), controller)
	initializeControllerFilters(controller, controllerName)
	initializeControllerVisitors(controller, controllerName)
	initializeControllerObservers(controller, controllerName)
	initializeControllerDelegates(controller, controllerName)
	handlerNames := []string{}
	for i := 0; i < ml; i++ {
		rmt := rtv.Method(i)
		if strings.HasPrefix(rmt.Name, "Handle") {
			logger.Debug.Printf("analyzing %s method %s", controllerName, rmt.Name)
			handleName := utils.KebabCaseString(rmt.Name[6:])
			rmv := rv.Method(i)
			numIn := rmv.Type().NumIn()
			numOut := rmv.Type().NumOut()
			if numOut > 2 {
				logger.Error.Printf("analyzing %s method:%s as handler while the handler output parameter count:%d sould not greater than 2", controllerName, rmt.Name, numOut)
				continue
			}
			if numIn > 2 {
				logger.Error.Printf("analyzing %s method:%s as handler while the handler input parameter count:%d sould not greater than 2", controllerName, rmt.Name, numIn)
				continue
			}
			h := &mqHandler{
				Name:       handleName,
				Group:      handleGroup,
				RoutingKey: fmt.Sprintf("%s.%s", handleGroup, handleName),
				caller:     rmv,
				inTypes:    make([]paramTypeWrapper, numIn),
				outTypes:   make([]paramTypeWrapper, numOut),
				controller: controller,
			}
			// logger.Trace.Printf("%s %s inputs:%d outputs:%d", controllerName, h.RoutingKey, numIn, numOut)
			for j := 0; j < numIn; j++ {
				ivt := rmv.Type().In(j)
				ptw := paramTypeWrapper{serializingType: paramSerializingType}
				ptw.initAndCheckConsumerMessage(ivt, cmt)
				h.inTypes[j] = ptw
			}
			for j := 0; j < numOut; j++ {
				ovt := rmv.Type().Out(j)
				ptw := paramTypeWrapper{serializingType: paramSerializingType}
				if ovt.Kind() == reflect.Interface {
					switch ovt.Name() {
					case "error":
						ptw.isError = true
						break
					case "StatusCodeResultType":
						ptw.hasStatusCode = true
						break
					case "HandlerError":
						ptw.isErrorStatus = true
						break
					}
					if true || false == ptw.isError || false == ptw.isErrorStatus {
						_, ok := ovt.MethodByName("StatusCode")
						if ok {
							ptw.hasStatusCode = true
							ptw.isErrorStatus = true
						} else {
							_, ok = ovt.MethodByName("Error")
							if ok {
								ptw.isError = true
							}
						}
					}
				} else {
					if ovt.Kind() == reflect.Ptr {
						ptw.isPtr = true
					}
					ptw.initAndCheckConsumerMessage(ovt, pmt)
				}
				h.outTypes[j] = ptw
			}
			if nil != h {
				result[h.RoutingKey] = h
				handlerNames = append(handlerNames, h.Name)
			}
		}
	}

	controller.afterAnalyzedHandlers(handlerNames)

	return result
}

func (w *paramTypeWrapper) init(valueType reflect.Type) {
	w.valueType = valueType
	var v reflect.Value
	if valueType.Kind() == reflect.Ptr {
		w.isPtr = true
		v = reflect.New(valueType.Elem())
	} else {
		w.isPtr = false
		v = reflect.New(valueType)
	}
	_, ok := v.Interface().(serializers.SerializableParam)
	if ok {
		w.isSerializable = true
	}
}
func (w *paramTypeWrapper) initAndCheckConsumerMessage(valueType reflect.Type, consumerType reflect.Type) {
	if valueType.Kind() == reflect.Ptr {
		if valueType.Elem().ConvertibleTo(consumerType) {
			w.isMQParameter = true
			w.valueType = valueType
			w.isPtr = true
		}
	} else if valueType.ConvertibleTo(consumerType) {
		w.isMQParameter = true
		w.valueType = valueType
		w.isPtr = false
	}
	if false == w.isMQParameter {
		w.init(valueType)
	}
}

func (w *paramTypeWrapper) parsePayload(payload []byte) (reflect.Value, error) {
	var v reflect.Value
	var err error
	if w.isPtr {
		v = reflect.New(w.valueType.Elem())
	} else {
		v = reflect.New(w.valueType)
	}

	// parse
	if w.isSerializable {
		serializable, ok := v.Interface().(serializers.SerializableParam)
		if ok {
			err = serializable.ParseFrom(payload)
		} else {
			// this condition would be avoided when analyzing controller, should not be triggered here.
			err = fmt.Errorf("The parameter %s where not serializable type", reflect.TypeOf(v).Elem().Name())
		}
	} else {
		serializer := serializers.GetSerializer(w.serializingType)
		if nil != serializer {
			err = serializer.ParseFrom(payload, v.Interface())
		} else {
			err = fmt.Errorf("Unknown or unsupported serialization type:%s", w.serializingType)
		}
	}

	if w.isPtr {
		return v, err
	}
	return v.Elem(), err
}

// GetParameterFieldSerializingTagName tag name for serializing
func (w *paramTypeWrapper) GetParameterFieldSerializingTagName() string {
	tagName := "json"
	switch w.serializingType {
	case serializers.SerializationTypeJSON:
		tagName = "json"
		break
	case serializers.SerializationTypeXML:
		tagName = "xml"
		break
	case serializers.SerializationTypeProtobuf:
		tagName = "protobuf"
		break
	case serializers.SerializationTypeHL7:
		tagName = "hl7"
		break
	default:
		logger.Error.Printf("get parameter field serializing tag name by unknown serializingType:%s", w.serializingType)
		break
	}
	return tagName
}

func getControllerSerializationType(controllerValue reflect.Value) string {
	serializationType := ""
	serializationStrategy, ok := controllerValue.Interface().(serializers.SerializationStrategy)
	if ok {
		serializationType = serializationStrategy.SerializationType()
	} else {
		serializationType = getFieldTagValue(controllerValue, "SerializationStrategy", "serialization")
	}

	if "" == serializationType {
		logger.Info.Printf("no controller %s handlers serialization type specified, consider as json serialization", controllerValue.Type().Name())
		serializationType = serializers.SerializationTypeJSON
	}
	return serializationType
}

func getFieldTagValue(value reflect.Value, fieldName string, tagName string) string {
	result := ""
	fieldType, ok := value.Type().FieldByName(fieldName)
	if ok {
		field := value.FieldByName(fieldName)
		if field.IsValid() {
			strValue, _ := field.Interface().(string)
			if strValue != "" {
				result = field.String()
			}
		}
		tagValue := fieldType.Tag.Get(tagName)
		if "" != tagValue && "" == result {
			result = tagValue
		}
	}
	return result
}

func getFieldTagValueAsList(value reflect.Value, fieldName string, tagName string) []string {
	strategyValue := getFieldTagValue(value, fieldName, tagName)
	var values []string
	if "" != strategyValue {
		eleNames := strings.Split(strategyValue, ",")
		values = make([]string, len(eleNames))
		for i, eleName := range eleNames {
			values[i] = strings.Trim(eleName, " ")
		}
	} else {
		values = []string{}
	}
	return values
}

func initializeControllerFilters(controller MQController, initNamePrefix string) {
	controller.InitializeFilters(initNamePrefix)
	strategy, ok := controller.(filters.FiltersStrategy)
	var controllerStrategyElements []filters.Filter
	if ok {
		controllerStrategyElements = strategy.Filters()
	} else {
		eleNames := getFieldTagValueAsList(reflect.ValueOf(controller).Elem(), "FiltersStrategy", "filters")
		controllerStrategyElements = []filters.Filter{}
		for _, eleName := range eleNames {
			v := filters.GetFilter(eleName)
			if nil != v {
				controllerStrategyElements = append(controllerStrategyElements, v)
			}
		}
	}
	if nil != controllerStrategyElements {
		for _, v := range controllerStrategyElements {
			controller.AttachFilter(v)
		}
	}
}

func initializeControllerVisitors(controller MQController, initNamePrefix string) {
	controller.InitializeVisitors(initNamePrefix)
	strategy, ok := controller.(visitors.VisitorsStrategy)
	var controllerStrategyElements []visitors.Visitor
	if ok {
		controllerStrategyElements = strategy.Visitors()
	} else {
		eleNames := getFieldTagValueAsList(reflect.ValueOf(controller).Elem(), "VisitorsStrategy", "visitors")
		controllerStrategyElements = []visitors.Visitor{}
		for _, eleName := range eleNames {
			v := visitors.GetVisitor(eleName)
			if nil != v {
				controllerStrategyElements = append(controllerStrategyElements, v)
			}
		}
	}
	if nil != controllerStrategyElements {
		for _, v := range controllerStrategyElements {
			controller.AttachVisitor(v)
		}
	}
}

func initializeControllerObservers(controller MQController, initNamePrefix string) {
	controller.InitializeObservers(initNamePrefix)
	strategy, ok := controller.(observers.ObserversStrategy)
	var controllerStrategyElements []observers.Observer
	if ok {
		controllerStrategyElements = strategy.Observers()
	} else {
		eleNames := getFieldTagValueAsList(reflect.ValueOf(controller).Elem(), "ObserversStrategy", "observers")
		controllerStrategyElements = []observers.Observer{}
		for _, eleName := range eleNames {
			v := observers.GetObserver(eleName)
			if nil != v {
				controllerStrategyElements = append(controllerStrategyElements, v)
			}
		}
	}
	if nil != controllerStrategyElements {
		for _, v := range controllerStrategyElements {
			controller.AttachObserver(v)
		}
	}
}

func initializeControllerDelegates(controller MQController, initNamePrefix string) {
	controller.InitializeDelegates(initNamePrefix)
	strategy, ok := controller.(delegates.DelegatesStrategy)
	var controllerStrategyElements []delegates.Delegate
	if ok {
		controllerStrategyElements = strategy.Delegates()
	} else {
		eleNames := getFieldTagValueAsList(reflect.ValueOf(controller).Elem(), "DelegatesStrategy", "delegates")
		controllerStrategyElements = []delegates.Delegate{}
		for _, eleName := range eleNames {
			v := delegates.GetDelegate(eleName)
			if nil != v {
				controllerStrategyElements = append(controllerStrategyElements, v)
			}
		}
	}
	if nil != controllerStrategyElements {
		for _, v := range controllerStrategyElements {
			controller.AttachDelegate(v)
		}
	}
}
